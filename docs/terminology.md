# 一些常听到的开发词汇

这些词语在与开发沟通的过程中，都是出现频率比较高的，以往每次听到并没有往下深究。但是现在想想，作为产品经理，对于这些高频出现的开发词汇，是必须知其然且知其所以然的。这样才能保证与开发能够正常且顺利的沟通，使项目/产品的推进更加顺畅。（以下将按照我平时遇到的出现较高的词汇进行汇总，排名不分先后=-=）

##cookies

* `定义`

Cookie，有时也用其复数形式 Cookies，是存储在用户本地终端上的数据。指某些网站为了辨别用户身份、进行session跟踪而存储在用户本地终端上的数据（通常经过加密）。也可以叫做浏览器缓存。

* `具体含义`

Cookie是小量信息，由网络服务器发送出来以存储在网络浏览器上，从而使该浏览器的访客再次回到该网络服务器时，可以从该浏览器读回此信息。这能够使浏览器记住访客的特定信息，比如上次访问的位置、花费的时间或用户首选项（比如样式表）。简单来说，Cookies就是服务器暂时存放在你电脑里的资料（.txt格式的文本文件），好让服务器用来辨认你的计算机。当用户在浏览网站时，Web服务器会先送一个小小的资料放在你的计算机上，Cookies会把你在网站上所打的文字或者一些选择都记录下来。当下次你再访问同一个网站，Web服务器会先看看有没有它上次留下的Cookies资料，有的话，就会依据Cookie里的内容来判断使用者，送出特定的网页内容给你。

* `主要用途`

举个例子来说，当你在一个网站上注册了一个新的账户，等到下次再访问该站时，会自动识别到你并向你问好。这就是Cookies的表现之一。前面我们说到，Cookies可以存储访问该站的用户的行为习惯等等的信息，比如什么时间访问，访问了哪些页面，在每个网页的停留时间等。利用这些信息，网站运营者一方面可以为用户提供个性化的服务，另一方面也可以通过Cookies了解所有用户的行为（用户画像），作为改善网站经营策略的参考。目前Cookies最广泛的是记录用户登录信息，这样下次访问时可以不需要输入自己的用户名、密码了（当然这种方便也存在用户信息泄密的问题，尤其是多个用户共用一台电脑时很容易出现这样的问题）。

另外，有人认为网站利用cookies可能存在侵犯用户隐私的问题，但由于大多用户对此了解不多，而且这种对用户个人信息的利用多数作为统计数据之用，不一定造成用户的直接损失，因此对于cookies与用户隐私权的问题并没有相关法律约束，很多网站仍然在利用cookie跟踪用户行为，有些程序要求用户必须开启cookie才能正常应用。

* `案例`

例如，你在某家航空公司站点查阅航班时刻表，该网站可能就创建了包含你旅行计划的Cookies，也可能它只记录了你在该站点上曾经访问过的Web页，在你下次访问时，网站根据你的情况对显示的内容进行调整，将你所感兴趣的内容放在前列。这是高级的Cookie应用。

再比如，当你来到一家新闻网站，但并不想查看任何商务新闻。网站允许他将该项选为关闭选项。从那时起（或者直到 cookie 逾期），他在访问 CNN 网页时将不会读到商务新闻。

如果希望对Cookie进行更进一步的了解，并且了解会话跟踪技术中Cookie与Session机制的不同，[请点这里](http://blog.csdn.net/fangaoxin/article/details/6952954/).

## Session

* `定义`

在计算机专业术语中，Session是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统之间所经过的时间，也被称为会话控制。

具体到Web中的Session指的就是用户在浏览某个网站时，从进入网站到关闭浏览器所经过的这段时间，也就是用户浏览这个网站所花费的时间，每个不同的用户与同一个服务器建立连接时所处的Session都是不同的。

* `工作原理`
 - 当一个session第一次被启用时，一个唯一的标识被存储于本地的cookie中。
 
 - 首先使用session_start()函数，PHP从session仓库中加载已经存储的session变量。
 
 - 当执行PHP脚本时，通过使用session_register()函数注册session变量。
 
 - 当PHP脚本执行结束时，未被销毁的session变量会被自动保存在本地一定路径下的session库中，这个路径可以通过php.ini文件中的session.save_path指定，下次浏览网页时可以加载使用。
 
* `功能与用途`

Session是用于保持状态的基于Web服务器的方法。Session允许通过将对象存储在Web副武器的内容中在整个用户会话过程中保持任何对象。它通常用于执行以下操作：

 - 存储需要在整个用户会话过程中保持其状态的信息，例如登录信息或用户浏览Web应用程序时所需要的其它信息。
 
 - 存储只需要在页面重新加载过程中或按功能分组的一组页面之间保持其状态的对象。
 
 - 在Web服务器上保持用户的状态信息供在任何时间从任何设备上的页面进行访问。因为浏览器不需要存储任何这种信息，所以可以使用任何浏览器，即使是像Pad或手机这样的浏览器设备。
 
 但是，随着越来越多用户登录，Session所需要的服务器内存量也会不断增加，访问Web应用的每个用户都生成一个单独的Session对象，每个Seesion对象的持续时间是用户访问的时间加上不活动的时间。如果每个Session中保持许多对象，并且许多用户同时使用Web应用（创建许多Session），则用于Session持久性的服务器内存量可能就会很大，从而影响了可伸缩性。
 
 * `衍生问题-Session超时`
 
 当用户登录网站后较长的一段时间没有与服务器进行交互，将会导致服务器上的用户会话数据（即Session）被销毁。此时，当用户再次操作网页时，如果服务器进行了Session校验，那么浏览器会提醒用户Session超时。那么由此我们可以知道，导致这个问题的关键词有二，一是“长时间”，二是“未操作”。那么针对这两个关键词的解决方法有以下两种：
 
  ```bash
  1、如果用户未操作的「长时间」超过了服务器配置的session超时时间，并导致session失效，那么我们延长session的超时时间，让用户原来的「长时间」与超时时间相比，变得不「长」，不就可以解决了吗？
　　2、如果用户是长时间「未操作」导致session失效，那么我们想办法产生「操作」，让用户每隔一小段时间就「操作」一次，与服务器产生交互，那么session自然也不会失效。
  ```
  
  一般来说，首先能够想到的是，通过改变服务器的配置，延长服务器的Session超时时间。不过在实际的工作应用中，一味的上调Session超时时间设置并不怎么常见，大多数需要实现该功能的网站都将解决问题的焦点集中在第二条思路上。例如，一些在线网站均采用定时刷新页面的方法来防止Session超时。最常见的两种实现方式如下：
  
  ```bash
  1、JavaScript+HTMLDOM，示例代码如下：
    1 functionrefresh(seconds){
    2 setTimeout("self.location.reload()",seconds*1000);
    3 }
    4 refresh(600);//调用方法启动定时刷新，数值单位：秒。
  2、通过meta标签来实现（在页面中添加meta标签refresh也可以指定每隔指定时间就刷新当前页面），示例代码如下：
    1 <metahttp-equiv="refresh"content="600"/>
    上述meta标签可以实现每过600秒就刷新一次当前页面。
  ```
  
  在上述两种方案中，较好的为第二种，因为如果当前页面是在IE浏览器的模式窗口中打开的，默认情况下，self.location.reload()方法将会失效，而refreshmeta标签在IE模式窗口下仍然有效。但是遗憾的是，这两种方法都存在一种几乎致命的缺陷，试想一下，如果在论坛发帖等需要用户输入内容的页面，用户花费较长的时间输入了许多文本内容，可是突然遇到了一个定时页面刷新，结果用户输入的所有内容都没了，估计这个时候用户连掐死你的心都有了……
  
  因此我们需要在当前页面本身不刷新、不影响用户的任何操作的情况下实现定时刷新。最常见的解决方法仍然有两种。
  
  一种是在当前页面添加一个隐藏的iframe，然后在该iframe里面实现定时刷新。并在服务器上编写对应的请求响应代码.
  
  ```bash
   1 <iframeid="hidden_iframe"style="display:none;"scrolling="no"frameborder="0"name="hidden_iframe"src="ping.php"></iframe>
   在ping.php中编写如下请求响应代码：
   1 <?php
   2 //每隔600秒刷新当前页面
   3 echo'<html><head><metahttp-equiv="refresh"content="600"/></head><body></body></html>';
   4 ?>
  ```

  另外一种则是使用JavaScriptImage对象来实现定时刷新,JavaScript代码如下：
  
  ```bash
   1 functionautoRefresh(seconds){
   2 if(typeofperiod=="undefined"){//如果是第一次执行
   3 period=seconds*1000;//定义全局变量period
   4 varbodyDOM=document.getElementsByTagName("body")[0];
   5 if(bodyDOM){
   6 bodyDOM.innerHTML+='<imgid="auto_refresh_img"src=""style="display:none"/>';//添加隐藏的图片
   7 imgDOM=document.getElementById("auto_refresh_img");//定义全局Image对象
   8 }
   9 }
   10 if(typeofimgDOM!="undefined"){
   11 imgDOM.src="ping.php?sid="+newDate().getTime();//防止缓存
   12 setTimeout("autoRefresh("+seconds+")",period);
   13 }
   14 }
   15 autoRefresh(600);//调用方法启动定时刷新

  和使用iframe来实现定时刷新一样，使用JavaScriptImage对象实现定时刷新，也需要在服务器端编写类似的请求响应代码。服务器的响应可以是文字等非图片内容，非图片内容只会造成图像加载失败，而我们的图像标签本身就是隐藏的，不管是加载成功还是失败都不会显示，毕竟我们的主要目的是发送请求给服务器，让服务器保持session处于活动状态。
  
  在上述两种方式中，各有其优缺点。
  
  使用iframe标签实现定时刷新的优点是：不需要编写JavaScript代码，可以在浏览器禁用JavaScript的情况下实现定时刷新；其缺点是：在某些不支持iframe标签的老式浏览器中没有效果，此外，iframe标签在浏览器中新增加了一个独立的页面，即使没有显示出来，不过其内部解析的window、document等对象仍然存在，占用的浏览器内存相对较多。
  
  使用Image对象的优点是：与iframe相比，占用的内存相对较少，支持Image的浏览器也相对较多(现代浏览器均支持)；缺点是：在浏览器禁用JavaScript的情况下就毫无用武之地了。
