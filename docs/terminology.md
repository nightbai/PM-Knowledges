# 一些常听到的开发词汇

这些词语在与开发沟通的过程中，都是出现频率比较高的，以往每次听到并没有往下深究。但是现在想想，作为产品经理，对于这些高频出现的开发词汇，是必须知其然且知其所以然的。这样才能保证与开发能够正常且顺利的沟通，使项目/产品的推进更加顺畅。以下将按照我平时遇到的出现较高的词汇进行知识点的整理汇总（内容均从公开网站渠道上获得，并非原创），排名不分先后=-=

## cookies

* `定义`

Cookie，有时也用其复数形式 Cookies，是存储在用户本地终端上的数据。指某些网站为了辨别用户身份、进行session跟踪而存储在用户本地终端上的数据（通常经过加密）。也可以叫做浏览器缓存。

* `具体含义`

Cookie是小量信息，由网络服务器发送出来以存储在网络浏览器上，从而使该浏览器的访客再次回到该网络服务器时，可以从该浏览器读回此信息。这能够使浏览器记住访客的特定信息，比如上次访问的位置、花费的时间或用户首选项（比如样式表）。简单来说，Cookies就是服务器暂时存放在你电脑里的资料（.txt格式的文本文件），好让服务器用来辨认你的计算机。当用户在浏览网站时，Web服务器会先送一个小小的资料放在你的计算机上，Cookies会把你在网站上所打的文字或者一些选择都记录下来。当下次你再访问同一个网站，Web服务器会先看看有没有它上次留下的Cookies资料，有的话，就会依据Cookie里的内容来判断使用者，送出特定的网页内容给你。

* `主要用途`

举个例子来说，当你在一个网站上注册了一个新的账户，等到下次再访问该站时，会自动识别到你并向你问好。这就是Cookies的表现之一。前面我们说到，Cookies可以存储访问该站的用户的行为习惯等等的信息，比如什么时间访问，访问了哪些页面，在每个网页的停留时间等。利用这些信息，网站运营者一方面可以为用户提供个性化的服务，另一方面也可以通过Cookies了解所有用户的行为（用户画像），作为改善网站经营策略的参考。目前Cookies最广泛的是记录用户登录信息，这样下次访问时可以不需要输入自己的用户名、密码了（当然这种方便也存在用户信息泄密的问题，尤其是多个用户共用一台电脑时很容易出现这样的问题）。

另外，有人认为网站利用cookies可能存在侵犯用户隐私的问题，但由于大多用户对此了解不多，而且这种对用户个人信息的利用多数作为统计数据之用，不一定造成用户的直接损失，因此对于cookies与用户隐私权的问题并没有相关法律约束，很多网站仍然在利用cookie跟踪用户行为，有些程序要求用户必须开启cookie才能正常应用。

* `案例`

例如，你在某家航空公司站点查阅航班时刻表，该网站可能就创建了包含你旅行计划的Cookies，也可能它只记录了你在该站点上曾经访问过的Web页，在你下次访问时，网站根据你的情况对显示的内容进行调整，将你所感兴趣的内容放在前列。这是高级的Cookie应用。

再比如，当你来到一家新闻网站，但并不想查看任何商务新闻。网站允许他将该项选为关闭选项。从那时起（或者直到 cookie 逾期），他在访问 CNN 网页时将不会读到商务新闻。

如果希望对Cookie进行更进一步的了解，并且了解会话跟踪技术中Cookie与Session机制的不同，[请点这里](http://blog.csdn.net/fangaoxin/article/details/6952954/).

## Session

* `定义`

在计算机专业术语中，Session是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统之间所经过的时间，也被称为会话控制。

具体到Web中的Session指的就是用户在浏览某个网站时，从进入网站到关闭浏览器所经过的这段时间，也就是用户浏览这个网站所花费的时间，每个不同的用户与同一个服务器建立连接时所处的Session都是不同的。

* `工作原理`
 - 当一个session第一次被启用时，一个唯一的标识被存储于本地的cookie中。
 
 - 首先使用session_start()函数，PHP从session仓库中加载已经存储的session变量。
 
 - 当执行PHP脚本时，通过使用session_register()函数注册session变量。
 
 - 当PHP脚本执行结束时，未被销毁的session变量会被自动保存在本地一定路径下的session库中，这个路径可以通过php.ini文件中的session.save_path指定，下次浏览网页时可以加载使用。
 
* `功能与用途`

Session是用于保持状态的基于Web服务器的方法。Session允许通过将对象存储在Web副武器的内容中在整个用户会话过程中保持任何对象。它通常用于执行以下操作：

 - 存储需要在整个用户会话过程中保持其状态的信息，例如登录信息或用户浏览Web应用程序时所需要的其它信息。
 
 - 存储只需要在页面重新加载过程中或按功能分组的一组页面之间保持其状态的对象。
 
 - 在Web服务器上保持用户的状态信息供在任何时间从任何设备上的页面进行访问。因为浏览器不需要存储任何这种信息，所以可以使用任何浏览器，即使是像Pad或手机这样的浏览器设备。
 
 但是，随着越来越多用户登录，Session所需要的服务器内存量也会不断增加，访问Web应用的每个用户都生成一个单独的Session对象，每个Seesion对象的持续时间是用户访问的时间加上不活动的时间。如果每个Session中保持许多对象，并且许多用户同时使用Web应用（创建许多Session），则用于Session持久性的服务器内存量可能就会很大，从而影响了可伸缩性。
 
 * `衍生问题-Session超时`
 
 当用户登录网站后较长的一段时间没有与服务器进行交互，将会导致服务器上的用户会话数据（即Session）被销毁。此时，当用户再次操作网页时，如果服务器进行了Session校验，那么浏览器会提醒用户Session超时。那么由此我们可以知道，导致这个问题的关键词有二，一是“长时间”，二是“未操作”。那么针对这两个关键词的解决方法有以下两种：
 
  ```bash
  1、如果用户未操作的「长时间」超过了服务器配置的session超时时间，并导致session失效，那么我们延长session的超时时间，让用户原来的「长时间」与超时时间相比，变得不「长」，不就可以解决了吗？
　　2、如果用户是长时间「未操作」导致session失效，那么我们想办法产生「操作」，让用户每隔一小段时间就「操作」一次，与服务器产生交互，那么session自然也不会失效。
  ```
  
  一般来说，首先能够想到的是，通过改变服务器的配置，延长服务器的Session超时时间。不过在实际的工作应用中，一味的上调Session超时时间设置并不怎么常见，大多数需要实现该功能的网站都将解决问题的焦点集中在第二条思路上。例如，一些在线网站均采用定时刷新页面的方法来防止Session超时。最常见的两种实现方式如下：
  
  ```bash
  1、JavaScript+HTMLDOM，示例代码如下：
    1 functionrefresh(seconds){
    2 setTimeout("self.location.reload()",seconds*1000);
    3 }
    4 refresh(600);//调用方法启动定时刷新，数值单位：秒。
  2、通过meta标签来实现（在页面中添加meta标签refresh也可以指定每隔指定时间就刷新当前页面），示例代码如下：
    1 <metahttp-equiv="refresh"content="600"/>
    上述meta标签可以实现每过600秒就刷新一次当前页面。
  ```
  
  在上述两种方案中，较好的为第二种，因为如果当前页面是在IE浏览器的模式窗口中打开的，默认情况下，self.location.reload()方法将会失效，而refreshmeta标签在IE模式窗口下仍然有效。但是遗憾的是，这两种方法都存在一种几乎致命的缺陷，试想一下，如果在论坛发帖等需要用户输入内容的页面，用户花费较长的时间输入了许多文本内容，可是突然遇到了一个定时页面刷新，结果用户输入的所有内容都没了，估计这个时候用户连掐死你的心都有了……
  
  因此我们需要在当前页面本身不刷新、不影响用户的任何操作的情况下实现定时刷新。最常见的解决方法仍然有两种。
  
  一种是在当前页面添加一个隐藏的iframe，然后在该iframe里面实现定时刷新。并在服务器上编写对应的请求响应代码.
  
  ```bash
   1 <iframeid="hidden_iframe"style="display:none;"scrolling="no"frameborder="0"name="hidden_iframe"src="ping.php"></iframe>
   在ping.php中编写如下请求响应代码：
   1 <?php
   2 //每隔600秒刷新当前页面
   3 echo'<html><head><metahttp-equiv="refresh"content="600"/></head><body></body></html>';
   4 ?>
  ```

  另外一种则是使用JavaScriptImage对象来实现定时刷新,JavaScript代码如下：
  
  ```bash
   1 functionautoRefresh(seconds){
   2 if(typeofperiod=="undefined"){//如果是第一次执行
   3 period=seconds*1000;//定义全局变量period
   4 varbodyDOM=document.getElementsByTagName("body")[0];
   5 if(bodyDOM){
   6 bodyDOM.innerHTML+='<imgid="auto_refresh_img"src=""style="display:none"/>';//添加隐藏的图片
   7 imgDOM=document.getElementById("auto_refresh_img");//定义全局Image对象
   8 }
   9 }
   10 if(typeofimgDOM!="undefined"){
   11 imgDOM.src="ping.php?sid="+newDate().getTime();//防止缓存
   12 setTimeout("autoRefresh("+seconds+")",period);
   13 }
   14 }
   15 autoRefresh(600);//调用方法启动定时刷新
  ```

  和使用iframe来实现定时刷新一样，使用JavaScriptImage对象实现定时刷新，也需要在服务器端编写类似的请求响应代码。服务器的响应可以是文字等非图片内容，非图片内容只会造成图像加载失败，而我们的图像标签本身就是隐藏的，不管是加载成功还是失败都不会显示，毕竟我们的主要目的是发送请求给服务器，让服务器保持session处于活动状态。
  
  在上述两种方式中，各有其优缺点。
  
  使用iframe标签实现定时刷新的优点是：不需要编写JavaScript代码，可以在浏览器禁用JavaScript的情况下实现定时刷新；其缺点是：在某些不支持iframe标签的老式浏览器中没有效果，此外，iframe标签在浏览器中新增加了一个独立的页面，即使没有显示出来，不过其内部解析的window、document等对象仍然存在，占用的浏览器内存相对较多。
  
  使用Image对象的优点是：与iframe相比，占用的内存相对较少，支持Image的浏览器也相对较多(现代浏览器均支持)；缺点是：在浏览器禁用JavaScript的情况下就毫无用武之地了。
  
  
如果希望对Cookie进行更进一步的了解，并且了解会话跟踪技术中Cookie与Session机制的不同，[请点这里](http://blog.csdn.net/fangaoxin/article/details/6952954/).

## 架构

我所理解的架构，是开发工程师在进入正式开发工序之前，为整个项目/产品/需求搭建的整体骨架，在该骨架上明确了整体分成了哪些部分，分别具备什么职能，各个部分之间有什么关系并通过哪些机制相互协作，在保证新的功能可以灵活进入原有结构的同时，还要保证结构的稳定性。

* `定义`
 
 架构最开始起源于建筑行业，英文是`Architecture`,在维基百科上，架构是这样定义的：
 
 ```js
 Architecture (Latin architectura, from the Greek ἀρχιτέκτων arkhitekton"architect", from ἀρχι- "chief" and τέκτων "builder") is both
 the process and the product of planning, designing, and constructing buildings and other physical structures。
 ```
 
 简单的总结整理一下，架构的定义可以按照下面的方式进行：
 
 - 根据要解决的问题，对目标系统的边界进行界定。
 
 - 对目标系统按照某个原则进行切分。切分的原则，要便于不同的角色对切分出来的内容，并行或串行地开展工作，一般并行才能提高效率，减少时间。
 
 - 对切分出来的部分，设立沟通机制。
 
 - 根据前一条，使得这些部分之间能够进行有机的联系，合并组装成为一个整体，完成目标系统的所有工作。
 
 * `计算机术语中的定义`
 
 架构，也叫软件架构，是有关软件整体结构与组建的抽象描述，用于指导大型软件系统各个方面的设计。架构描述语言（ADL）用于描述软件的体系架构。现在已经有多种架构描述语言，如Wright，Acme，C2，Darwin等。ADL的基本构成包括组件、连接器和配置。

 架构是对存储在Active Directory（活动目录）中的对象类别和属性的描述。对于每一个对象类别来说，该架构定义了对象类必须具有的属性，它也可以有附加的属性，并且该对象可以是它的父对象。
 
 * `架构的种类`
 
 一般架构可以分成三种：
 
 1. 逻辑架构，是指系统中各元件之间的关系。比如用户界面，数据库，外部系统接口，商业逻辑元件，等等。
 
 2. 物理架构，是指元件是怎样放到硬件上的。比如网络分流器、代理服务器、WEB服务器、应用服务器、报表服务器、整合服务器、存储服务器。主机等等。
 
 3. 系统架构，是指系统的非功能性，比如可扩展性、可靠性、强壮性、灵活性、性能等。
 
 * `架构设计的目标`
 
 正如同软件本身有其要达到的目标，软件架构设计要达到如下的目标：
 
1.可靠性（Reliable）。软件系统对于用户的商业经营和管理来说极为重要，因此软件系统必须非常可靠。

2.安全性（Secure）。软件系统所承担的交易的商业价值极高，系统的安全性非常重要。

3.可扩展性（Scalable）。软件必须能够在用户的使用率、用户的数目增加很快的情况下，保持合理的性能。只有这样，才能适应用户的市场扩展得可能性。

4.可定制化（Customizable）。同样的一套软件，可以根据客户群的不同和市场需求的变化进行调整。

5.可伸缩 （Extensible）。在新技术出现的时候，一个软件系统应当允许导入新技术，从而对现有系统进行功能和性能的扩展。

6.可维护性（Maintainable）。软件系统的维护包括两方面，一是排除现有的错误，二是将新的软件需求反映到现有系统中去。一个易于维护的系统可以有效地降低技术支持的花费。

7.客户体验（Customer Experience）。软件系统必须易于使用。

8.市场时机（Time to Market）。软件用户要面临同业竞争，软件提供商也要面临同业竞争。以最快的速度争夺市场先机非常重要。
 
 * `参考内容`
 
 详细内容除百度百科等基本知识介绍之外，还可参照[对软件架构设计的一些总结和理解](http://blog.csdn.net/cooldragon/article/details/48241965)一文，除此之外，如果自身所在公司有比较牛的架构师，可以直接去请教，并且在项目中通过实际接触，对架构的作用产生更直接的印象，毕竟，一家公司的架构师均是一些技术水平较高、经验较为丰富的人，他们需要承担软件系统的架构设计，也就是需要设计系统的元件如何划分、元件之间如何发生相互作用，以及系统中逻辑的、物理的、系统的重要决定的做出。

## WebSocket

WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。在JavaEE7中也实现了WebSocket协议。

`过去实现即时通讯（real-time）——轮询（polling）`

现很多网站为了实现即时通讯(real-time)，所用的技术都是轮询(polling)。

轮询是在特定的的时间间隔(time interval)（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客服端的浏览器。

这种传统的HTTP request 的模式带来很明显的缺点————浏览器需要不断的向服务器发出请求(request)，然而HTTP request 的header是非常长的，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽。

最比较新的技术去做轮询的效果是Comet – 用了AJAX。但这种技术虽然可达到全双工通信，但依然需要发出请求(reuqest)。

`现在实现即时通讯（real-time）——WebSocket`

在 WebSocket API，浏览器和服务器只需要要做一个握手的动作(在实现websocket连线过程中，需要通过浏览器发出websocket连线请求，然后服务器发出回应，这个过程通常称为“握手” (handshaking))，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。在此WebSocket 协议中，为我们实现即时服务带来了两大好处：

1. Header:互相沟通的Header是很小的-大概只有 2 Bytes

2. Server Push:服务器可以主动传送数据给客户端

[关于WebSocket的原理，可以参考这篇博客](http://blog.csdn.net/frank_good/article/details/50856585),这篇博客的语言通俗易懂，有趣而不生硬。
